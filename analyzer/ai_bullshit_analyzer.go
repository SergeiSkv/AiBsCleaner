package analyzer

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"

	"github.com/SergeiSkv/AiBsCleaner/models"
)

// AIBullshitAnalyzer detects AI-generated bullshit code patterns
type AIBullshitAnalyzer struct {
	name string

	// Configurable thresholds
	cyclomaticComplexityThreshold int
	nestingDepthThreshold         int
	maxStatementsForGoroutine     int
}

const (
	// Default thresholds - tuned based on Go community standards
	defaultCyclomaticComplexity = 20 // Go community: 10-20, we use 20 to reduce noise
	defaultNestingDepth         = 7  // Increased from 6 to 7
	defaultMaxStmtsGoroutine    = 10 // Simple functions shouldn't use goroutines
)

// NewAIBullshitAnalyzer creates a new AI bullshit detector
func NewAIBullshitAnalyzer() Analyzer {
	return &AIBullshitAnalyzer{
		name:                          "AI Bullshit Detector",
		cyclomaticComplexityThreshold: defaultCyclomaticComplexity,
		nestingDepthThreshold:         defaultNestingDepth,
		maxStatementsForGoroutine:     defaultMaxStmtsGoroutine,
	}
}

func (a *AIBullshitAnalyzer) Name() string {
	return a.name
}

func (a *AIBullshitAnalyzer) Analyze(node interface{}, fset *token.FileSet) []*models.Issue {
	// Pre-allocate slice to avoid multiple reallocations
	issues := make([]*models.Issue, 0, 10)

	astNode, ok := node.(ast.Node)
	if !ok {
		return issues
	}

	file, ok := astNode.(*ast.File)
	if !ok {
		return issues
	}

	// Check file-level comments for AI patterns
	for _, cg := range file.Comments {
		for _, comment := range cg.List {
			text := strings.ToLower(comment.Text)
			if strings.Contains(text, "ai-generated") ||
				strings.Contains(text, "generated by ai") ||
				strings.Contains(text, "copilot") ||
				strings.Contains(text, "chatgpt") ||
				strings.Contains(text, "claude") ||
				strings.Contains(text, "bard") {
				pos := fset.Position(comment.Pos())
				issues = append(
					issues, &models.Issue{
						File:       pos.Filename,
						Line:       pos.Line,
						Column:     pos.Column,
						Position:   pos,
						Type:       models.IssueAIGeneratedComment,
						Severity:   models.SeverityLevelLow,
						Message:    "AI-generated comment detected",
						Suggestion: "Review and improve AI-generated code",
						Code:       comment.Text,
					},
				)
			}
		}
	}

	ast.Inspect(
		file, func(n ast.Node) bool {
			switch node := n.(type) {
			case *ast.FuncDecl:
				issues = append(issues, a.checkOverEngineering(node, fset)...)
				issues = append(issues, a.checkUnnecessaryComplexity(node, fset)...)
				issues = append(issues, a.checkUnnecessaryGoroutine(node, fset)...)
			case *ast.InterfaceType:
				issues = append(issues, a.checkInterfaceAbuse(node, fset)...)
			case *ast.GenDecl:
				issues = append(issues, a.checkGenericInterfaceNames(node, fset)...)
			}
			return true
		},
	)

	return issues
}

func (a *AIBullshitAnalyzer) checkOverEngineering(fn *ast.FuncDecl, fset *token.FileSet) []*models.Issue {
	var issues []*models.Issue

	if fn.Name == nil || fn.Body == nil {
		return issues
	}

	pos := fset.Position(fn.Pos())
	funcName := fn.Name.Name

	// Skip binding/serialization code where complex patterns are expected
	if isBindingOrSerializationCode(pos.Filename, funcName) {
		return issues
	}

	// Check for structural indicators of over-engineering without name-based detection
	if len(fn.Body.List) < 5 && a.hasComplexStructure(fn) {
		issues = append(
			issues, &models.Issue{
				File:       pos.Filename,
				Line:       pos.Line,
				Column:     pos.Column,
				Position:   pos,
				Type:       models.IssueAIOverengineeredSimple,
				Severity:   models.SeverityLevelHigh,
				Message:    "Over-engineered solution for simple task - AI bullshit detected",
				Suggestion: "Simplify: this function is too simple for complex patterns",
				Code:       "Function: " + funcName,
				WhyBad: fmt.Sprintf(
					`Complex pattern for a %d-line function is overkill.
PROBLEMS:
• Unnecessary abstraction layers add complexity
• Extra allocations for interface dispatch
• Harder to understand and maintain
• Prevents compiler optimizations (inlining)
IMPACT: 10-20x more code, 2-5x slower execution
BETTER: Use direct function calls without patterns`, len(fn.Body.List),
				),
			},
		)
	}

	return issues
}

func (a *AIBullshitAnalyzer) hasComplexStructure(fn *ast.FuncDecl) bool {
	if fn.Body == nil {
		return false
	}

	// Check for structural complexity indicators
	hasInterfaces := false
	hasTypeAssertions := false
	hasReflection := false

	ast.Inspect(
		fn.Body, func(n ast.Node) bool {
			switch node := n.(type) {
			case *ast.InterfaceType:
				// Ignore empty interfaces used for casts like interface{}
				if node.Methods != nil && len(node.Methods.List) > 0 {
					hasInterfaces = true
				}
			case *ast.TypeAssertExpr:
				hasTypeAssertions = true
			case *ast.CallExpr:
				if call, ok := n.(*ast.CallExpr); ok {
					if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
						if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == pkgReflect {
							hasReflection = true
						}
					}
				}
			}
			return true
		},
	)

	// Consider complex if it has multiple complexity indicators
	complexityScore := 0
	if hasInterfaces {
		complexityScore++
	}
	if hasTypeAssertions {
		complexityScore++
	}
	if hasReflection {
		complexityScore++
	}

	return complexityScore >= 2
}

// isBindingOrSerializationCode checks if code is binding/serialization where reflection is expected
// This is a package-level function, not a method, so it can be used without receiver
func isBindingOrSerializationCode(filename, funcName string) bool {
	lowerPath := strings.ToLower(filename)

	// Check file path patterns
	if strings.Contains(lowerPath, "binding") ||
		strings.Contains(lowerPath, "binder") ||
		strings.Contains(lowerPath, "serializ") ||
		strings.Contains(lowerPath, "marshal") ||
		strings.Contains(lowerPath, "unmarshal") {
		return true
	}

	// Check function name patterns
	lowerFunc := strings.ToLower(funcName)
	if strings.Contains(lowerFunc, "bind") ||
		strings.Contains(lowerFunc, "marshal") ||
		strings.Contains(lowerFunc, "unmarshal") ||
		strings.Contains(lowerFunc, "decode") ||
		strings.Contains(lowerFunc, "encode") ||
		(strings.HasPrefix(lowerFunc, "set") && strings.Contains(lowerFunc, "type")) {
		return true
	}

	return false
}

func (a *AIBullshitAnalyzer) checkUnnecessaryComplexity(fn *ast.FuncDecl, fset *token.FileSet) []*models.Issue {
	var issues []*models.Issue

	if fn.Name == nil || fn.Body == nil {
		return issues
	}

	pos := fset.Position(fn.Pos())
	cyclomaticComplexity := a.calculateCyclomaticComplexity(fn)
	nestingDepth := a.calculateNestingDepth(fn)

	// Check for excessive complexity
	if cyclomaticComplexity > a.cyclomaticComplexityThreshold {
		issues = append(
			issues, &models.Issue{
				File:     pos.Filename,
				Line:     pos.Line,
				Column:   pos.Column,
				Position: pos,
				Type:     models.IssueAIUnnecessaryComplexity,
				Severity: models.SeverityLevelHigh,
				Message: fmt.Sprintf(
					"Function has cyclomatic complexity of %d (threshold: %d)", cyclomaticComplexity, a.cyclomaticComplexityThreshold,
				),
				Suggestion: "Break down into smaller functions",
				Code:       fmt.Sprintf("Function: %s", fn.Name.Name),
				WhyBad: fmt.Sprintf(
					`High cyclomatic complexity makes code hard to test and maintain.
PROBLEMS:
• %d decision points - exponential test combinations
• Difficult to understand control flow
• Higher bug probability
• Hard to refactor safely
IMPACT: Maintenance time increases exponentially with complexity
BETTER: Split into focused, single-purpose functions`, cyclomaticComplexity,
				),
			},
		)
	}

	if nestingDepth > a.nestingDepthThreshold {
		issues = append(
			issues, &models.Issue{
				File:       pos.Filename,
				Line:       pos.Line,
				Column:     pos.Column,
				Position:   pos,
				Type:       models.IssueAIUnnecessaryComplexity,
				Severity:   models.SeverityLevelMedium,
				Message:    fmt.Sprintf("Function has nesting depth of %d (threshold: %d)", nestingDepth, a.nestingDepthThreshold),
				Suggestion: "Reduce nesting with early returns or extract functions",
				Code:       fmt.Sprintf("Function: %s", fn.Name.Name),
				WhyBad: fmt.Sprintf(
					`Deep nesting reduces code readability and increases cognitive load.
PROBLEMS:
• %d nesting levels require mental stack tracking
• Arrow anti-pattern (code drifting to the right)
• Higher chance of logic errors
IMPACT: Code review time increases, bugs hide in nested blocks
BETTER: Use early returns, extract helper functions, invert conditions`, nestingDepth,
				),
			},
		)
	}

	return issues
}

func (a *AIBullshitAnalyzer) calculateCyclomaticComplexity(fn *ast.FuncDecl) int {
	complexity := 1 // Base complexity

	ast.Inspect(
		fn, func(n ast.Node) bool {
			switch n := n.(type) {
			case *ast.IfStmt, *ast.ForStmt, *ast.RangeStmt, *ast.SwitchStmt, *ast.TypeSwitchStmt:
				complexity++
			case *ast.CaseClause:
				// Each case adds to complexity (except default)
				if clause := n; clause.List != nil {
					complexity++
				}
			}
			return true
		},
	)

	return complexity
}

func (a *AIBullshitAnalyzer) calculateNestingDepth(fn *ast.FuncDecl) int {
	maxDepth := 0
	currentDepth := 0

	ast.Inspect(
		fn, func(n ast.Node) bool {
			if _, ok := n.(*ast.BlockStmt); ok {
				currentDepth++
				if currentDepth > maxDepth {
					maxDepth = currentDepth
				}
			}
			return true
		},
	)

	ast.Inspect(
		fn, func(n ast.Node) bool {
			if _, ok := n.(*ast.BlockStmt); ok {
				currentDepth--
			}
			return false // Visit nodes on exit
		},
	)

	return maxDepth
}

func (a *AIBullshitAnalyzer) checkInterfaceAbuse(iface *ast.InterfaceType, fset *token.FileSet) []*models.Issue {
	var issues []*models.Issue

	// Check for single-method interfaces (potential over-abstraction)
	if iface.Methods != nil && len(iface.Methods.List) == 1 {
		pos := fset.Position(iface.Pos())
		issues = append(
			issues, &models.Issue{
				File:       pos.Filename,
				Line:       pos.Line,
				Column:     pos.Column,
				Position:   pos,
				Type:       models.IssueAIOverAbstraction,
				Severity:   models.SeverityLevelLow,
				Message:    "Single-method interface detected - potential over-abstraction",
				Suggestion: "Consider if interface is necessary or use concrete type",
			},
		)
	}

	return issues
}

func (a *AIBullshitAnalyzer) checkUnnecessaryGoroutine(fn *ast.FuncDecl, fset *token.FileSet) []*models.Issue {
	var issues []*models.Issue

	if fn.Body == nil {
		return issues
	}

	// Detect goroutine used for simple synchronous operations
	hasGoroutine := false
	hasChannelOp := false
	stmtCount := len(fn.Body.List)

	ast.Inspect(
		fn.Body, func(n ast.Node) bool {
			switch node := n.(type) {
			case *ast.GoStmt:
				hasGoroutine = true
			case *ast.SendStmt:
				hasChannelOp = true
			case *ast.UnaryExpr:
				if node.Op == token.ARROW {
					hasChannelOp = true
				}
			}
			return true
		},
	)

	// If function is simple and uses goroutine+channel for sync work
	if hasGoroutine && hasChannelOp && stmtCount < a.maxStatementsForGoroutine {
		pos := fset.Position(fn.Pos())
		issues = append(
			issues, &models.Issue{
				File:       pos.Filename,
				Line:       pos.Line,
				Column:     pos.Column,
				Position:   pos,
				Type:       models.IssueAIGoroutineOverkill,
				Severity:   models.SeverityLevelMedium,
				Message:    "Unnecessary goroutine for synchronous operation",
				Suggestion: "Remove goroutine and channel, execute directly",
				Code:       fmt.Sprintf("Function: %s", fn.Name.Name),
				WhyBad: `Goroutines add overhead when not needed for concurrency.
PROBLEMS:
• Goroutine creation overhead (~2KB stack minimum)
• Channel synchronization overhead
• Unnecessary context switching
• Makes simple code complex
IMPACT: 10-100x slower than direct execution for simple operations
BETTER: Use goroutines only for true concurrent or async work`,
			},
		)
	}

	return issues
}

func (a *AIBullshitAnalyzer) checkGenericInterfaceNames(decl *ast.GenDecl, fset *token.FileSet) []*models.Issue {
	var issues []*models.Issue

	if decl.Tok != token.TYPE {
		return issues
	}

	// Generic interface names that AI often generates
	genericNames := map[string]bool{
		"Handler":  true,
		"Manager":  true,
		"Provider": true,
		"Service":  true,
		"Factory":  true,
		"Builder":  true,
		"Strategy": true,
		"Adapter":  true,
		"Wrapper":  true,
	}

	for _, spec := range decl.Specs {
		typeSpec, ok := spec.(*ast.TypeSpec)
		if !ok {
			continue
		}

		interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
		if !ok || interfaceType.Methods == nil {
			continue
		}

		// Check if interface has generic name
		if genericNames[typeSpec.Name.Name] {
			pos := fset.Position(typeSpec.Pos())
			issues = append(
				issues, &models.Issue{
					File:       pos.Filename,
					Line:       pos.Line,
					Column:     pos.Column,
					Position:   pos,
					Type:       models.IssueAIUnnecessaryInterface,
					Severity:   models.SeverityLevelLow,
					Message:    fmt.Sprintf("Generic interface name '%s' detected - likely AI-generated", typeSpec.Name.Name),
					Suggestion: "Use more specific, domain-driven interface names",
					Code:       typeSpec.Name.Name,
				},
			)
		}
	}

	return issues
}
