//go:build legacytests
// +build legacytests

package analyzer

import (
	"go/parser"
	"go/token"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/SergeiSkv/AiBsCleaner/models"
)

// Test constants removed - using IssueType enum instead

func TestAIBullshitAnalyzer_DetectsOverEngineering(t *testing.T) {
	code := `
package test

import "reflect"

// Over-engineered simple function with interfaces and reflection
type Calculator interface {
	Calculate(a, b int) int
}

type SimpleCalculator struct{}

func (s *SimpleCalculator) Calculate(a, b int) int {
	// Using reflection for simple addition - AI bullshit
	result := reflect.ValueOf(a).Int() + reflect.ValueOf(b).Int()
	return int(result)
}

func NewCalculator() Calculator {
	return &SimpleCalculator{}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	// Should detect over-engineering (reflection + interfaces for simple task)
	foundOverEngineering := false
	foundReflection := false

	for _, issue := range issues {
		if issue.Type == models.IssueAIOverengineeredSimple {
			foundOverEngineering = true
		}
		if issue.Type == models.IssueAIUnnecessaryReflection {
			foundReflection = true
		}
	}

	if !foundOverEngineering && !foundReflection {
		t.Error("Expected to find AI_OVER_ENGINEERING or AI_UNNECESSARY_REFLECTION issue")
	}
}

func TestCheckUnnecessaryComplexity(t *testing.T) {
	tests := []struct {
		name       string
		code       string
		expected   models.IssueType
		shouldFind bool
	}{
		{
			name: "high cyclomatic complexity",
			code: `package main
func complexFunc(x int) int {
	if x > 10 { x++ }
	if x > 20 { x++ }
	if x > 30 { x++ }
	if x > 40 { x++ }
	if x > 50 { x++ }
	if x > 60 { x++ }
	if x > 70 { x++ }
	if x > 80 { x++ }
	if x > 90 { x++ }
	if x > 100 { x++ }
	if x > 110 { x++ }
	if x > 120 { x++ }
	if x > 130 { x++ }
	if x > 140 { x++ }
	if x > 150 { x++ }
	if x > 160 { x++ }
	return x
}`,
			expected:   models.IssueAIUnnecessaryComplexity,
			shouldFind: true,
		},
		{
			name: "deeply nested blocks",
			code: `package main
func deeplyNested() {
	{
		{
			{
				{
					{
						{
							{
								println("deeply nested")
							}
						}
					}
				}
			}
		}
	}
}`,
			expected:   models.IssueAIUnnecessaryComplexity,
			shouldFind: true,
		},
		{
			name: "normal complexity - no issues",
			code: `package main
func getValue(x int) int {
	if x > 10 {
		return 10
	}
	if x > 5 {
		return 5
	}
	return 0
}`,
			expected:   models.IssueAIUnnecessaryComplexity,
			shouldFind: false,
		},
	}

	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				fset := token.NewFileSet()
				file, err := parser.ParseFile(fset, "test.go", tt.code, parser.ParseComments)
				require.NoError(t, err)

				analyzer := NewAIBullshitAnalyzer()
				issues := analyzer.Analyze(file, fset)

				found := false
				for _, issue := range issues {
					if issue.Type == tt.expected {
						found = true
						break
					}
				}

				assert.Equal(t, tt.shouldFind, found, "Issue detection mismatch for: %s", tt.name)
			},
		)
	}
}

func TestCheckAIPatterns(t *testing.T) {
	tests := []struct {
		name        string
		commentText string
		shouldMatch bool
	}{
		{
			name:        "AI-generated comment",
			commentText: "// This function was generated by AI",
			shouldMatch: true,
		},
		{
			name:        "Copilot comment",
			commentText: "// Copilot suggested this implementation",
			shouldMatch: true,
		},
		{
			name:        "ChatGPT comment",
			commentText: "// ChatGPT helped write this",
			shouldMatch: true,
		},
		{
			name:        "normal comment",
			commentText: "// Calculate the sum of two numbers",
			shouldMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				code := `package main
` + tt.commentText + `
func test() {
	println("test")
}`
				fset := token.NewFileSet()
				file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
				require.NoError(t, err)

				analyzer := NewAIBullshitAnalyzer()
				issues := analyzer.Analyze(file, fset)

				found := false
				for _, issue := range issues {
					if issue.Type == models.IssueAIGeneratedComment {
						found = true
						break
					}
				}

				assert.Equal(t, tt.shouldMatch, found, "AI pattern detection mismatch for: %s", tt.commentText)
			},
		)
	}
}

func TestAIBullshitAnalyzer_DetectsUnnecessaryGoroutines(t *testing.T) {
	code := `
package test

func AddNumbers(a, b int) int {
	resultCh := make(chan int, 1)
	
	go func() {
		resultCh <- a + b
	}()
	
	return <-resultCh
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	// Should detect unnecessary goroutines
	found := false
	for _, issue := range issues {
		if issue.Type == models.IssueAIGoroutineOverkill {
			found = true
			break
		}
	}

	if !found {
		t.Error("Expected to find AI_GOROUTINE_OVERKILL issue")
	}
}

func TestAIBullshitAnalyzer_DetectsUnnecessaryReflection(t *testing.T) {
	code := `
package test

import "reflect"

func GetValue(x int) int {
	val := reflect.ValueOf(x)
	return int(val.Int())
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	// Should detect unnecessary reflection
	found := false
	for _, issue := range issues {
		if issue.Type == models.IssueAIUnnecessaryReflection {
			found = true
			break
		}
	}

	if !found {
		t.Error("Expected to find AI_UNNECESSARY_REFLECTION issue")
	}
}

func TestAIBullshitAnalyzer_DetectsUnnecessaryInterfaces(t *testing.T) {
	code := `
package test

type Handler interface {
	Handle(data string)
}

type Manager interface {
	Manage()
}

type Provider interface {
	Provide() int
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	// Should detect generic interface names
	interfaceIssues := 0
	for _, issue := range issues {
		if issue.Type == models.IssueAIUnnecessaryInterface {
			interfaceIssues++
		}
	}

	if interfaceIssues < 3 {
		t.Errorf("Expected at least 3 AI_UNNECESSARY_INTERFACE issues, got %d", interfaceIssues)
	}
}

func TestAIBullshitAnalyzer_IgnoresLegitimatePatterns(t *testing.T) {
	code := `
package test

import (
	"context"
	"sync"
)

// Legitimate use of goroutines for parallel processing
func ProcessItems(items []string) []string {
	var wg sync.WaitGroup
	results := make([]string, len(items))
	
	for i, item := range items {
		wg.Add(1)
		go func(idx int, val string) {
			defer wg.Done()
			// Simulate expensive operation
			results[idx] = processItem(val)
		}(i, item)
	}
	
	wg.Wait()
	return results
}

func processItem(item string) string {
	// Expensive processing
	return item
}

// Legitimate Factory for complex object creation
type DatabaseConnectionFactory interface {
	CreateConnection(ctx context.Context, config Config) (Connection, error)
}

type Config struct {
	Host     string
	Port     int
	Database string
}

type Connection interface {
	Query(ctx context.Context, sql string) error
	Close() error
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	// Should not detect issues for legitimate patterns
	for _, issue := range issues {
		if issue.Type == models.IssueAIGoroutineOverkill {
			t.Error("Should not flag legitimate goroutine usage")
		}
		if issue.Type == models.IssueAIOverengineeredSimple && issue.Line < 30 {
			t.Error("Should not flag legitimate factory pattern for complex objects")
		}
	}
}

func TestAIBullshitAnalyzer_StructLayoutHelpers(t *testing.T) {
	code := `
package test

import (
	"go/types"
	"unsafe"
)

func getTypeSize(t types.Type) int64 {
	switch typ := t.(type) {
	case *types.Basic:
		return 1
	case *types.Pointer:
		return int64(unsafe.Sizeof(uintptr(0)))
	case *types.Interface:
		return int64(unsafe.Sizeof((*interface{})(nil)))
	default:
		return 8
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	require.NoError(t, err)

	analyzer := NewAIBullshitAnalyzer()
	issues := analyzer.Analyze(file, fset)

	for _, issue := range issues {
		if issue.Type == models.IssueAIOverengineeredSimple {
			t.Fatalf("unexpected IssueAIOverengineeredSimple: %+v", issue)
		}
	}
}

func BenchmarkAIBullshitAnalyzer(b *testing.B) {
	code := `
package test

type Factory interface {
	Create() Strategy
}

type Strategy interface {
	Execute() int
}

func DoWork(x int) int {
	ch := make(chan int)
	go func() { ch <- x * 2 }()
	return <-ch
}
`

	fset := token.NewFileSet()
	file, _ := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
	analyzer := NewAIBullshitAnalyzer()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = analyzer.Analyze(file, fset)
	}
}

func FuzzAIBullshitAnalyzer(f *testing.F) {
	// Add seed corpus
	f.Add(
		`package test
func Add(a, b int) int { return a + b }`,
	)

	f.Add(
		`package test
type Factory interface { Create() interface{} }`,
	)

	f.Add(
		`package test
import "reflect"
func Get(x int) int { return reflect.ValueOf(x).Interface().(int) }`,
	)

	f.Fuzz(
		func(t *testing.T, code string) {
			fset := token.NewFileSet()
			file, err := parser.ParseFile(fset, "test.go", code, parser.ParseComments)
			if err != nil {
				// Invalid Go code, skip
				return
			}

			analyzer := NewAIBullshitAnalyzer()
			// Should not panic
			_ = analyzer.Analyze(file, fset)
		},
	)
}
